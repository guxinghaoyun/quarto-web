<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6&nbsp; PointNet系列网络 – 现代计算机视觉</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapter11/11.6_3D目标检测.html" rel="next">
<link href="../chapter11/11.4_点云基础与处理.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-234273d1456647dabc34a594ac50e507.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-0348920b7671f696dc9078d39bff215e.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-234273d1456647dabc34a594ac50e507.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-43a518227082ac35b3113d490d8c8312.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-6ba6813c27d4e98062636b1311a23212.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-43a518227082ac35b3113d490d8c8312.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="mermaid-theme" content="default">
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../assets/cv-book.css">
</head>

<body class="nav-sidebar floating quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="展开或折叠侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapter11/11.0_概述.html">第十一章：三维视觉与点云处理</a></li><li class="breadcrumb-item"><a href="../chapter11/11.5_PointNet系列网络.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">PointNet系列网络</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="展开或折叠侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="搜索" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">现代计算机视觉</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/guxinghaoyun/quarto-web" title="源代码" class="quarto-navigation-tool px-1" aria-label="源代码"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="切换深色模式"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">第十一章：三维视觉与点云处理</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.0_概述.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">概述</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.1_相机标定与几何.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">相机标定与几何</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.2_立体匹配与深度估计.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">立体匹配与深度估计</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.3_三维重建.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">三维重建</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.4_点云基础与处理.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">点云基础与处理</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.5_PointNet系列网络.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">PointNet系列网络</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.6_3D目标检测.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">3D目标检测</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapter11/11.7_应用案例分析.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">应用案例分析</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">目录</h2>
   
  <ul>
  <li><a href="#引言深度学习在点云处理中的革命性突破" id="toc-引言深度学习在点云处理中的革命性突破" class="nav-link active" data-scroll-target="#引言深度学习在点云处理中的革命性突破"><span class="header-section-number">6.1</span> 引言：深度学习在点云处理中的革命性突破</a></li>
  <li><a href="#核心概念" id="toc-核心概念" class="nav-link" data-scroll-target="#核心概念"><span class="header-section-number">6.2</span> 核心概念</a>
  <ul class="collapse">
  <li><a href="#pointnet的核心思想深度解析" id="toc-pointnet的核心思想深度解析" class="nav-link" data-scroll-target="#pointnet的核心思想深度解析"><span class="header-section-number">6.2.1</span> PointNet的核心思想深度解析</a></li>
  </ul></li>
  <li><a href="#理论基础从对称函数到自注意力机制" id="toc-理论基础从对称函数到自注意力机制" class="nav-link" data-scroll-target="#理论基础从对称函数到自注意力机制"><span class="header-section-number">6.3</span> 理论基础：从对称函数到自注意力机制</a>
  <ul class="collapse">
  <li><a href="#pointnet的理论基础" id="toc-pointnet的理论基础" class="nav-link" data-scroll-target="#pointnet的理论基础"><span class="header-section-number">6.3.1</span> PointNet的理论基础</a></li>
  <li><a href="#pointnet的理论基础-1" id="toc-pointnet的理论基础-1" class="nav-link" data-scroll-target="#pointnet的理论基础-1"><span class="header-section-number">6.3.2</span> PointNet++的理论基础</a></li>
  <li><a href="#point-transformer的理论基础" id="toc-point-transformer的理论基础" class="nav-link" data-scroll-target="#point-transformer的理论基础"><span class="header-section-number">6.3.3</span> Point-Transformer的理论基础</a></li>
  <li><a href="#损失函数设计" id="toc-损失函数设计" class="nav-link" data-scroll-target="#损失函数设计"><span class="header-section-number">6.3.4</span> 损失函数设计</a></li>
  </ul></li>
  <li><a href="#算法实现" id="toc-算法实现" class="nav-link" data-scroll-target="#算法实现"><span class="header-section-number">6.4</span> 算法实现</a>
  <ul class="collapse">
  <li><a href="#pointnet的核心实现" id="toc-pointnet的核心实现" class="nav-link" data-scroll-target="#pointnet的核心实现"><span class="header-section-number">6.4.1</span> PointNet的核心实现</a></li>
  <li><a href="#pointnet的核心实现-1" id="toc-pointnet的核心实现-1" class="nav-link" data-scroll-target="#pointnet的核心实现-1"><span class="header-section-number">6.4.2</span> PointNet++的核心实现</a></li>
  <li><a href="#point-transformer的核心实现" id="toc-point-transformer的核心实现" class="nav-link" data-scroll-target="#point-transformer的核心实现"><span class="header-section-number">6.4.3</span> Point-Transformer的核心实现</a></li>
  </ul></li>
  <li><a href="#网络性能评估" id="toc-网络性能评估" class="nav-link" data-scroll-target="#网络性能评估"><span class="header-section-number">6.5</span> 网络性能评估</a>
  <ul class="collapse">
  <li><a href="#网络性能对比分析" id="toc-网络性能对比分析" class="nav-link" data-scroll-target="#网络性能对比分析"><span class="header-section-number">6.5.1</span> 网络性能对比分析</a></li>
  <li><a href="#网络架构演进分析" id="toc-网络架构演进分析" class="nav-link" data-scroll-target="#网络架构演进分析"><span class="header-section-number">6.5.2</span> 网络架构演进分析</a></li>
  <li><a href="#数据集性能基准测试" id="toc-数据集性能基准测试" class="nav-link" data-scroll-target="#数据集性能基准测试"><span class="header-section-number">6.5.3</span> 数据集性能基准测试</a></li>
  <li><a href="#应用场景适应性分析" id="toc-应用场景适应性分析" class="nav-link" data-scroll-target="#应用场景适应性分析"><span class="header-section-number">6.5.4</span> 应用场景适应性分析</a></li>
  </ul></li>
  <li><a href="#小结" id="toc-小结" class="nav-link" data-scroll-target="#小结"><span class="header-section-number">6.6</span> 小结</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/guxinghaoyun/quarto-web/edit/main/chapter11/11.5_PointNet系列网络.qmd" class="toc-action"><i class="bi bi-github"></i>编辑该页面</a></li><li><a href="https://github.com/guxinghaoyun/quarto-web/issues/new" class="toc-action"><i class="bi empty"></i>反馈问题</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapter11/11.0_概述.html">第十一章：三维视觉与点云处理</a></li><li class="breadcrumb-item"><a href="../chapter11/11.5_PointNet系列网络.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">PointNet系列网络</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">PointNet系列网络</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="引言深度学习在点云处理中的革命性突破" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="引言深度学习在点云处理中的革命性突破"><span class="header-section-number">6.1</span> 引言：深度学习在点云处理中的革命性突破</h2>
<p>传统的点云处理方法主要依赖手工设计的几何特征和统计分析，虽然在特定场景下表现良好，但面临着特征表达能力有限、泛化性能不足等问题。2017年，斯坦福大学的Charles Qi等人提出了PointNet网络，首次实现了直接在无序点云上进行深度学习，开启了点云深度学习的新时代。</p>
<p>PointNet的核心创新在于解决了点云数据的<strong>无序性</strong>和<strong>置换不变性</strong>问题。与图像的规则网格结构不同，点云中的点没有固定的排列顺序，传统的卷积神经网络无法直接应用。PointNet通过设计对称函数（如max pooling）来聚合点特征，确保网络输出不受点的排列顺序影响。</p>
<p>随着研究的深入，PointNet系列网络不断演进：<strong>PointNet++</strong>引入了层次化特征学习，能够捕获局部几何结构；<strong>Point-Transformer</strong>则将Transformer架构引入点云处理，通过自注意力机制实现更强的特征表达能力。这些网络的发展不仅推动了点云分类、分割等基础任务的性能提升，也为三维目标检测、场景理解等高级应用奠定了基础。</p>
<p>本节将系统介绍PointNet系列网络的核心思想、技术演进和实现细节，重点阐述这些网络如何突破传统方法的局限性，实现端到端的点云特征学习。</p>
</section>
<section id="核心概念" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="核心概念"><span class="header-section-number">6.2</span> 核心概念</h2>
<p><strong>对称函数与置换不变性</strong>是PointNet系列网络的核心设计原则。点云数据的一个重要特性是其无序性：同一个物体的点云可以有多种不同的点排列方式，但它们应该被识别为同一个物体。这要求网络具有置换不变性，即对于点集<span class="math inline">\{p_1, p_2, ..., p_n\}</span>的任意排列<span class="math inline">\{p_{\sigma(1)}, p_{\sigma(2)}, ..., p_{\sigma(n)}\}</span>，网络的输出应该保持不变。</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph PointNet核心架构
        A["输入点云&lt;br/&gt;N × 3"]
        B["共享MLP&lt;br/&gt;特征提取"]
        C["点特征&lt;br/&gt;N × 1024"]
        D["对称函数&lt;br/&gt;Max Pooling"]
        E["全局特征&lt;br/&gt;1 × 1024"]
    end
    
    subgraph 置换不变性保证
        F["点排列1&lt;br/&gt;[p1,p2,p3]"]
        G["点排列2&lt;br/&gt;[p3,p1,p2]"]
        H["点排列3&lt;br/&gt;[p2,p3,p1]"]
    end
    
    subgraph 网络输出
        I["分类结果&lt;br/&gt;类别概率"]
        J["分割结果&lt;br/&gt;点级标签"]
    end
    
    A --&gt; B --&gt; C --&gt; D --&gt; E
    
    F --&gt; A
    G --&gt; A
    H --&gt; A
    
    E --&gt; I
    C --&gt; J
    
    classDef coreNode fill:#42a5f5,stroke:#1565c0,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    classDef permNode fill:#ffb74d,stroke:#e65100,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    classDef outputNode fill:#66bb6a,stroke:#2e7d32,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    
    classDef coreSubgraph fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1,font-weight:bold
    classDef permSubgraph fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#bf360c,font-weight:bold
    classDef outputSubgraph fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,color:#1b5e20,font-weight:bold
    
    class A,B,C,D,E coreNode
    class F,G,H permNode
    class I,J outputNode
    
    class PointNet核心架构 coreSubgraph
    class 置换不变性保证 permSubgraph
    class 网络输出 outputSubgraph
    
    linkStyle 0,1,2,3,4,5,6,7,8 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.23：PointNet网络的核心架构与置换不变性设计</em></p>
<p><strong>层次化特征学习</strong>是PointNet++的重要创新。PointNet虽然能够提取全局特征，但缺乏对局部几何结构的建模能力。PointNet++通过引入Set Abstraction层，实现了类似CNN中的层次化特征学习：</p>
<ul>
<li><strong>采样层（Sampling）</strong>：使用最远点采样（FPS）选择代表性点</li>
<li><strong>分组层（Grouping）</strong>：在每个采样点周围构建局部邻域</li>
<li><strong>特征提取层（PointNet）</strong>：对每个局部邻域应用PointNet提取特征</li>
</ul>
<p><strong>自注意力机制</strong>是Point-Transformer的核心技术。受Transformer在自然语言处理和计算机视觉领域成功的启发，Point-Transformer将自注意力机制引入点云处理，能够建模长距离依赖关系和复杂的几何结构。</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    subgraph PointNet特点
        A["全局特征&lt;br/&gt;整体形状"]
        B["置换不变&lt;br/&gt;顺序无关"]
        C["简单高效&lt;br/&gt;易于实现"]
    end
    
    subgraph PointNet++特点
        D["层次特征&lt;br/&gt;局部+全局"]
        E["多尺度&lt;br/&gt;不同分辨率"]
        F["鲁棒性强&lt;br/&gt;密度变化"]
    end
    
    subgraph Point-Transformer特点
        G["自注意力&lt;br/&gt;长距离依赖"]
        H["位置编码&lt;br/&gt;几何感知"]
        I["表达能力强&lt;br/&gt;复杂结构"]
    end
    
    A --&gt; D
    B --&gt; E
    C --&gt; F
    
    D --&gt; G
    E --&gt; H
    F --&gt; I
    
    classDef pointnetNode fill:#64b5f6,stroke:#1565c0,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    classDef pointnet2Node fill:#ba68c8,stroke:#7b1fa2,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    classDef transformerNode fill:#ef5350,stroke:#c62828,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    
    classDef pointnetSubgraph fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1,font-weight:bold
    classDef pointnet2Subgraph fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#4a148c,font-weight:bold
    classDef transformerSubgraph fill:#ffebee,stroke:#c62828,stroke-width:2px,color:#b71c1c,font-weight:bold
    
    class A,B,C pointnetNode
    class D,E,F pointnet2Node
    class G,H,I transformerNode
    
    class PointNet特点 pointnetSubgraph
    class PointNet++特点 pointnet2Subgraph
    class Point-Transformer特点 transformerSubgraph
    
    linkStyle 0,1,2,3,4,5 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.24：PointNet系列网络的技术演进与特点对比</em></p>
<section id="pointnet的核心思想深度解析" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="pointnet的核心思想深度解析"><span class="header-section-number">6.2.1</span> PointNet的核心思想深度解析</h3>
<p><strong>问题背景</strong>： 传统的深度学习方法主要针对规则数据结构设计，如图像的网格结构、序列的时序结构。然而，点云数据具有三个独特挑战： 1. <strong>无序性</strong>：点云中点的排列顺序是任意的，不存在固定的邻域关系 2. <strong>置换不变性</strong>：网络输出必须对点的重新排列保持不变 3. <strong>几何变换敏感性</strong>：点云容易受到旋转、平移等几何变换的影响</p>
<p><strong>创新突破</strong>： PointNet通过三个关键创新解决了上述挑战： 1. <strong>对称函数设计</strong>：使用max pooling等对称函数实现置换不变性，确保网络输出不受点顺序影响 2. <strong>T-Net变换网络</strong>：学习输入和特征的几何变换，提高对旋转、平移的鲁棒性 3. <strong>理论保证</strong>：证明了任何连续的置换不变函数都可以用PointNet的形式近似表示</p>
<p><strong>技术特点</strong>： - <strong>端到端学习</strong>：直接从原始点云学习特征，无需手工设计特征 - <strong>统一架构</strong>：同一网络可用于分类、分割等多种任务 - <strong>计算高效</strong>：相比体素化方法，避免了稀疏数据的存储和计算开销</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph PointNet详细架构
        A["输入点云&lt;br/&gt;N × 3"] --&gt; B["T-Net&lt;br/&gt;输入变换&lt;br/&gt;3×3矩阵"]
        B --&gt; C["MLP&lt;br/&gt;64-64维&lt;br/&gt;逐点变换"]
        C --&gt; D["T-Net&lt;br/&gt;特征变换&lt;br/&gt;64×64矩阵"]
        D --&gt; E["MLP&lt;br/&gt;64-128-1024维&lt;br/&gt;深层特征"]
        E --&gt; F["Max Pooling&lt;br/&gt;对称聚合&lt;br/&gt;1×1024"]
        F --&gt; G["MLP&lt;br/&gt;512-256-k维&lt;br/&gt;分类输出"]
    end

    subgraph 关键创新点
        H["置换不变性&lt;br/&gt;对称函数max"]
        I["几何鲁棒性&lt;br/&gt;T-Net变换"]
        J["理论保证&lt;br/&gt;万能逼近"]
    end

    subgraph 损失函数
        K["分类损失&lt;br/&gt;交叉熵"]
        L["正则化损失&lt;br/&gt;变换矩阵"]
        M["总损失&lt;br/&gt;加权组合"]
    end

    F --&gt; H
    B --&gt; I
    D --&gt; I
    G --&gt; J

    G --&gt; K
    D --&gt; L
    K --&gt; M
    L --&gt; M

    classDef archNode fill:#42a5f5,stroke:#1565c0,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef innovationNode fill:#ba68c8,stroke:#7b1fa2,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef lossNode fill:#ef5350,stroke:#c62828,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px

    classDef archSubgraph fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1,font-weight:bold
    classDef innovationSubgraph fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#4a148c,font-weight:bold
    classDef lossSubgraph fill:#ffebee,stroke:#c62828,stroke-width:2px,color:#b71c1c,font-weight:bold

    class A,B,C,D,E,F,G archNode
    class H,I,J innovationNode
    class K,L,M lossNode

    class PointNet详细架构 archSubgraph
    class 关键创新点 innovationSubgraph
    class 损失函数 lossSubgraph

    linkStyle 0,1,2,3,4,5,6,7,8,9,10,11,12,13 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.24a：PointNet网络的详细架构与关键创新点</em></p>
</section>
</section>
<section id="理论基础从对称函数到自注意力机制" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="理论基础从对称函数到自注意力机制"><span class="header-section-number">6.3</span> 理论基础：从对称函数到自注意力机制</h2>
<p>PointNet系列网络的理论基础涉及对称函数理论、层次化表示学习和注意力机制。下面我们详细介绍这些核心理论。</p>
<section id="pointnet的理论基础" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1" class="anchored" data-anchor-id="pointnet的理论基础"><span class="header-section-number">6.3.1</span> PointNet的理论基础</h3>
<p><strong>1. 对称函数与万能逼近定理</strong></p>
<p>PointNet的核心思想是使用对称函数来处理无序点集。对于点集<span class="math inline">S = \{x_1, x_2, ..., x_n\}</span>，其中<span class="math inline">x_i \in \mathbb{R}^d</span>，我们希望学习一个函数<span class="math inline">f: 2^{\mathbb{R}^d} \rightarrow \mathbb{R}^k</span>，使得对于<span class="math inline">S</span>的任意排列<span class="math inline">\pi(S)</span>，都有<span class="math inline">f(S) = f(\pi(S))</span>。</p>
<p>PointNet将这个函数分解为： <span class="math display">f(\{x_1, ..., x_n\}) = \rho \left( \max_{i=1,...,n} \{h(x_i)\} \right)</span></p>
<p>其中： - <span class="math inline">h: \mathbb{R}^d \rightarrow \mathbb{R}^K</span>是一个多层感知机，对每个点独立应用 - <span class="math inline">\max</span>是逐元素的最大值操作，保证置换不变性 - <span class="math inline">\rho: \mathbb{R}^K \rightarrow \mathbb{R}^k</span>是另一个多层感知机，处理聚合后的特征</p>
<p><strong>理论保证</strong>：Zaheer等人证明了，任何连续的置换不变函数都可以表示为上述形式，其中<span class="math inline">h</span>和<span class="math inline">\rho</span>是连续函数。这为PointNet的设计提供了理论依据。</p>
<p><strong>2. 变换网络（T-Net）</strong></p>
<p>为了提高网络对几何变换的鲁棒性，PointNet引入了变换网络T-Net，学习一个变换矩阵<span class="math inline">T \in \mathbb{R}^{k \times k}</span>：</p>
<p><span class="math display">T = \text{T-Net}(\{x_1, ..., x_n\})</span></p>
<p>变换后的特征为： <span class="math display">x_i' = T \cdot h(x_i)</span></p>
<p>为了保证变换矩阵接近正交矩阵，添加了正则化项： <span class="math display">L_{reg} = \|I - TT^T\|_F^2</span></p>
<p>其中<span class="math inline">\|\cdot\|_F</span>是Frobenius范数。</p>
</section>
<section id="pointnet的理论基础-1" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2" class="anchored" data-anchor-id="pointnet的理论基础-1"><span class="header-section-number">6.3.2</span> PointNet++的理论基础</h3>
<p><strong>1. 层次化特征学习</strong></p>
<p>PointNet++的核心思想是构建层次化的点特征表示。设第<span class="math inline">l</span>层有<span class="math inline">N_l</span>个点，每个点<span class="math inline">p_i^{(l)}</span>有特征<span class="math inline">f_i^{(l)} \in \mathbb{R}^{C_l}</span>。</p>
<p><strong>Set Abstraction层</strong>的数学表示为： <span class="math display">\{p_i^{(l+1)}, f_i^{(l+1)}\}_{i=1}^{N_{l+1}} = \text{SA}(\{p_i^{(l)}, f_i^{(l)}\}_{i=1}^{N_l})</span></p>
<p>具体包含三个步骤：</p>
<ul>
<li><strong>采样</strong>：使用最远点采样（FPS）选择<span class="math inline">N_{l+1}</span>个中心点</li>
<li><strong>分组</strong>：对每个中心点<span class="math inline">p_i^{(l+1)}</span>，找到半径<span class="math inline">r</span>内的邻居点集合： <span class="math display">\mathcal{N}_i = \{j : \|p_j^{(l)} - p_i^{(l+1)}\| \leq r\}</span></li>
<li><strong>特征聚合</strong>：对每个局部区域应用PointNet： <span class="math display">f_i^{(l+1)} = \max_{j \in \mathcal{N}_i} \{h(p_j^{(l)} - p_i^{(l+1)}, f_j^{(l)})\}</span></li>
</ul>
<p><strong>2. 多尺度分组</strong></p>
<p>为了处理点云密度不均匀的问题，PointNet++采用多尺度分组策略：</p>
<p><span class="math display">f_i^{(l+1)} = \text{Concat}[f_i^{(l+1,1)}, f_i^{(l+1,2)}, ..., f_i^{(l+1,M)}]</span></p>
<p>其中<span class="math inline">f_i^{(l+1,m)}</span>是在尺度<span class="math inline">m</span>下的特征，通过不同半径<span class="math inline">r_m</span>的分组得到。</p>
</section>
<section id="point-transformer的理论基础" class="level3" data-number="6.3.3">
<h3 data-number="6.3.3" class="anchored" data-anchor-id="point-transformer的理论基础"><span class="header-section-number">6.3.3</span> Point-Transformer的理论基础</h3>
<p><strong>1. 自注意力机制</strong></p>
<p>Point-Transformer将Transformer的自注意力机制扩展到点云数据。对于点<span class="math inline">i</span>，其更新后的特征为：</p>
<p><span class="math display">y_i = \sum_{j \in \mathcal{N}(i)} \alpha_{ij} (W_v x_j + \delta_{ij})</span></p>
<p>其中注意力权重<span class="math inline">\alpha_{ij}</span>计算为： <span class="math display">\alpha_{ij} = \text{softmax}_j(\phi(W_q x_i, W_k x_j + \delta_{ij}))</span></p>
<p>这里： - <span class="math inline">W_q, W_k, W_v</span>是查询、键、值的线性变换矩阵 - <span class="math inline">\delta_{ij}</span>是位置编码，捕获点<span class="math inline">i</span>和<span class="math inline">j</span>之间的几何关系 - <span class="math inline">\phi</span>是位置编码函数，通常使用MLP实现</p>
<p><strong>2. 位置编码</strong></p>
<p>位置编码<span class="math inline">\delta_{ij}</span>对于点云处理至关重要，它编码了点之间的几何关系：</p>
<p><span class="math display">\delta_{ij} = \text{MLP}(p_i - p_j)</span></p>
<p>其中<span class="math inline">p_i - p_j</span>是两点之间的相对位置向量。</p>
<p><strong>3. 向量注意力</strong></p>
<p>为了更好地处理几何信息，Point-Transformer使用向量注意力：</p>
<p><span class="math display">\alpha_{ij} = \text{softmax}_j(\gamma(\psi(W_q x_i) - \psi(W_k x_j) + \delta_{ij}))</span></p>
<p>其中<span class="math inline">\gamma</span>和<span class="math inline">\psi</span>是非线性变换函数。</p>
</section>
<section id="损失函数设计" class="level3" data-number="6.3.4">
<h3 data-number="6.3.4" class="anchored" data-anchor-id="损失函数设计"><span class="header-section-number">6.3.4</span> 损失函数设计</h3>
<p><strong>1. 分类任务</strong></p>
<p>对于点云分类，使用交叉熵损失： <span class="math display">L_{cls} = -\sum_{c=1}^C y_c \log(\hat{y}_c)</span></p>
<p>其中<span class="math inline">y_c</span>是真实标签，<span class="math inline">\hat{y}_c</span>是预测概率。</p>
<p><strong>2. 分割任务</strong></p>
<p>对于点云分割，对每个点计算交叉熵损失： <span class="math display">L_{seg} = -\frac{1}{N} \sum_{i=1}^N \sum_{c=1}^C y_{i,c} \log(\hat{y}_{i,c})</span></p>
<p><strong>3. 正则化项</strong></p>
<p>为了提高网络的泛化能力，通常添加正则化项： <span class="math display">L_{total} = L_{task} + \lambda_1 L_{reg} + \lambda_2 \|W\|_2^2</span></p>
<p>其中<span class="math inline">L_{task}</span>是任务相关的损失，<span class="math inline">L_{reg}</span>是变换网络的正则化项，<span class="math inline">\|W\|_2^2</span>是权重衰减项。</p>
<p>这些理论为PointNet系列网络的设计提供了坚实的数学基础，确保了网络能够有效处理点云数据的特殊性质。</p>
</section>
</section>
<section id="算法实现" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="算法实现"><span class="header-section-number">6.4</span> 算法实现</h2>
<p>下面我们介绍PointNet系列网络的核心算法实现，重点展示网络架构的关键组件和设计思想。</p>
<section id="pointnet的核心实现" class="level3" data-number="6.4.1">
<h3 data-number="6.4.1" class="anchored" data-anchor-id="pointnet的核心实现"><span class="header-section-number">6.4.1</span> PointNet的核心实现</h3>
<p>PointNet的核心是通过共享MLP和对称函数实现置换不变性：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> pointnet_forward(x):</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="co">"""PointNet前向传播核心逻辑"""</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="co"># 1. 输入变换：T-Net学习3×3变换矩阵</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    trans_input <span class="op">=</span> input_transform_net(x)  <span class="co"># 学习输入空间的对齐变换</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    x <span class="op">=</span> apply_transformation(x, trans_input)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="co"># 2. 逐点特征提取：共享MLP处理每个点</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    x <span class="op">=</span> shared_mlp(x)  <span class="co"># [B, N, 3] -&gt; [B, N, 64]</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="co"># 3. 特征变换：T-Net学习64×64变换矩阵</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    trans_feat <span class="op">=</span> feature_transform_net(x)  <span class="co"># 学习特征空间的对齐变换</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    x <span class="op">=</span> apply_transformation(x, trans_feat)</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="co"># 4. 深层特征提取：提取高维特征</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    x <span class="op">=</span> deep_shared_mlp(x)  <span class="co"># [B, N, 64] -&gt; [B, N, 1024]</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="co"># 5. 对称函数聚合：实现置换不变性</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    global_feature <span class="op">=</span> max_pooling(x)  <span class="co"># [B, N, 1024] -&gt; [B, 1024]</span></span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="co"># 6. 分类预测：全连接层输出类别</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    output <span class="op">=</span> classification_mlp(global_feature)</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">return</span> output, trans_feat</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="kw">def</span> t_net_core(x, k):</span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="co">"""T-Net变换网络核心逻辑"""</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>    <span class="co"># 特征提取：逐点MLP + 全局池化</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>    features <span class="op">=</span> shared_mlp_layers(x)  <span class="co"># [B, N, k] -&gt; [B, N, 1024]</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>    global_feat <span class="op">=</span> max_pooling(features)  <span class="co"># [B, N, 1024] -&gt; [B, 1024]</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a>    <span class="co"># 变换矩阵预测：MLP输出k×k矩阵</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    transform_matrix <span class="op">=</span> mlp_to_matrix(global_feat, k)  <span class="co"># [B, 1024] -&gt; [B, k, k]</span></span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a>    <span class="co"># 正则化：初始化为单位矩阵</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    identity <span class="op">=</span> torch.eye(k)</span>
<span id="cb1-36"><a href="#cb1-36"></a>    transform_matrix <span class="op">=</span> transform_matrix <span class="op">+</span> identity</span>
<span id="cb1-37"><a href="#cb1-37"></a></span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="cf">return</span> transform_matrix</span>
<span id="cb1-39"><a href="#cb1-39"></a></span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="kw">def</span> feature_transform_regularizer(trans_matrix):</span>
<span id="cb1-41"><a href="#cb1-41"></a>    <span class="co">"""特征变换正则化：约束变换矩阵接近正交"""</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="co"># 计算 T^T * T - I 的Frobenius范数</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>    should_be_identity <span class="op">=</span> torch.bmm(trans_matrix.transpose(<span class="dv">2</span>,<span class="dv">1</span>), trans_matrix)</span>
<span id="cb1-44"><a href="#cb1-44"></a>    identity <span class="op">=</span> torch.eye(trans_matrix.size(<span class="dv">1</span>))</span>
<span id="cb1-45"><a href="#cb1-45"></a>    regularization_loss <span class="op">=</span> torch.norm(should_be_identity <span class="op">-</span> identity, dim<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb1-46"><a href="#cb1-46"></a>    <span class="cf">return</span> torch.mean(regularization_loss)</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="pointnet的核心实现-1" class="level3" data-number="6.4.2">
<h3 data-number="6.4.2" class="anchored" data-anchor-id="pointnet的核心实现-1"><span class="header-section-number">6.4.2</span> PointNet++的核心实现</h3>
<p>PointNet++通过Set Abstraction层实现层次化特征学习：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">def</span> farthest_point_sample(xyz, npoint):</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="co">"""最远点采样算法"""</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    device <span class="op">=</span> xyz.device</span>
<span id="cb2-4"><a href="#cb2-4"></a>    B, N, C <span class="op">=</span> xyz.shape</span>
<span id="cb2-5"><a href="#cb2-5"></a>    centroids <span class="op">=</span> torch.zeros(B, npoint, dtype<span class="op">=</span>torch.<span class="bu">long</span>).to(device)</span>
<span id="cb2-6"><a href="#cb2-6"></a>    distance <span class="op">=</span> torch.ones(B, N).to(device) <span class="op">*</span> <span class="fl">1e10</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    farthest <span class="op">=</span> torch.randint(<span class="dv">0</span>, N, (B,), dtype<span class="op">=</span>torch.<span class="bu">long</span>).to(device)</span>
<span id="cb2-8"><a href="#cb2-8"></a>    batch_indices <span class="op">=</span> torch.arange(B, dtype<span class="op">=</span>torch.<span class="bu">long</span>).to(device)</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(npoint):</span>
<span id="cb2-11"><a href="#cb2-11"></a>        centroids[:, i] <span class="op">=</span> farthest</span>
<span id="cb2-12"><a href="#cb2-12"></a>        centroid <span class="op">=</span> xyz[batch_indices, farthest, :].view(B, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a>        dist <span class="op">=</span> torch.<span class="bu">sum</span>((xyz <span class="op">-</span> centroid) <span class="op">**</span> <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-14"><a href="#cb2-14"></a>        mask <span class="op">=</span> dist <span class="op">&lt;</span> distance</span>
<span id="cb2-15"><a href="#cb2-15"></a>        distance[mask] <span class="op">=</span> dist[mask]</span>
<span id="cb2-16"><a href="#cb2-16"></a>        farthest <span class="op">=</span> torch.<span class="bu">max</span>(distance, <span class="op">-</span><span class="dv">1</span>)[<span class="dv">1</span>]</span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a>    <span class="cf">return</span> centroids</span>
<span id="cb2-19"><a href="#cb2-19"></a></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="kw">def</span> query_ball_point(radius, nsample, xyz, new_xyz):</span>
<span id="cb2-21"><a href="#cb2-21"></a>    <span class="co">"""球形邻域查询"""</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    device <span class="op">=</span> xyz.device</span>
<span id="cb2-23"><a href="#cb2-23"></a>    B, N, C <span class="op">=</span> xyz.shape</span>
<span id="cb2-24"><a href="#cb2-24"></a>    _, S, _ <span class="op">=</span> new_xyz.shape</span>
<span id="cb2-25"><a href="#cb2-25"></a>    group_idx <span class="op">=</span> torch.arange(N, dtype<span class="op">=</span>torch.<span class="bu">long</span>).to(device).view(<span class="dv">1</span>, <span class="dv">1</span>, N).repeat([B, S, <span class="dv">1</span>])</span>
<span id="cb2-26"><a href="#cb2-26"></a></span>
<span id="cb2-27"><a href="#cb2-27"></a>    sqrdists <span class="op">=</span> square_distance(new_xyz, xyz)</span>
<span id="cb2-28"><a href="#cb2-28"></a>    group_idx[sqrdists <span class="op">&gt;</span> radius <span class="op">**</span> <span class="dv">2</span>] <span class="op">=</span> N</span>
<span id="cb2-29"><a href="#cb2-29"></a>    group_idx <span class="op">=</span> group_idx.sort(dim<span class="op">=-</span><span class="dv">1</span>)[<span class="dv">0</span>][:, :, :nsample]</span>
<span id="cb2-30"><a href="#cb2-30"></a>    group_first <span class="op">=</span> group_idx[:, :, <span class="dv">0</span>].view(B, S, <span class="dv">1</span>).repeat([<span class="dv">1</span>, <span class="dv">1</span>, nsample])</span>
<span id="cb2-31"><a href="#cb2-31"></a>    mask <span class="op">=</span> group_idx <span class="op">==</span> N</span>
<span id="cb2-32"><a href="#cb2-32"></a>    group_idx[mask] <span class="op">=</span> group_first[mask]</span>
<span id="cb2-33"><a href="#cb2-33"></a></span>
<span id="cb2-34"><a href="#cb2-34"></a>    <span class="cf">return</span> group_idx</span>
<span id="cb2-35"><a href="#cb2-35"></a></span>
<span id="cb2-36"><a href="#cb2-36"></a><span class="kw">class</span> SetAbstraction(nn.Module):</span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="co">"""Set Abstraction层：PointNet++的核心组件"""</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, npoint, radius, nsample, in_channel, mlp, group_all):</span>
<span id="cb2-39"><a href="#cb2-39"></a>        <span class="bu">super</span>(SetAbstraction, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb2-40"><a href="#cb2-40"></a>        <span class="va">self</span>.npoint <span class="op">=</span> npoint</span>
<span id="cb2-41"><a href="#cb2-41"></a>        <span class="va">self</span>.radius <span class="op">=</span> radius</span>
<span id="cb2-42"><a href="#cb2-42"></a>        <span class="va">self</span>.nsample <span class="op">=</span> nsample</span>
<span id="cb2-43"><a href="#cb2-43"></a>        <span class="va">self</span>.mlp_convs <span class="op">=</span> nn.ModuleList()</span>
<span id="cb2-44"><a href="#cb2-44"></a>        <span class="va">self</span>.mlp_bns <span class="op">=</span> nn.ModuleList()</span>
<span id="cb2-45"><a href="#cb2-45"></a></span>
<span id="cb2-46"><a href="#cb2-46"></a>        last_channel <span class="op">=</span> in_channel</span>
<span id="cb2-47"><a href="#cb2-47"></a>        <span class="cf">for</span> out_channel <span class="kw">in</span> mlp:</span>
<span id="cb2-48"><a href="#cb2-48"></a>            <span class="va">self</span>.mlp_convs.append(nn.Conv2d(last_channel, out_channel, <span class="dv">1</span>))</span>
<span id="cb2-49"><a href="#cb2-49"></a>            <span class="va">self</span>.mlp_bns.append(nn.BatchNorm2d(out_channel))</span>
<span id="cb2-50"><a href="#cb2-50"></a>            last_channel <span class="op">=</span> out_channel</span>
<span id="cb2-51"><a href="#cb2-51"></a></span>
<span id="cb2-52"><a href="#cb2-52"></a>        <span class="va">self</span>.group_all <span class="op">=</span> group_all</span>
<span id="cb2-53"><a href="#cb2-53"></a></span>
<span id="cb2-54"><a href="#cb2-54"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, xyz, points):</span>
<span id="cb2-55"><a href="#cb2-55"></a>        <span class="co">"""</span></span>
<span id="cb2-56"><a href="#cb2-56"></a><span class="co">        xyz: 点坐标 (B, N, 3)</span></span>
<span id="cb2-57"><a href="#cb2-57"></a><span class="co">        points: 点特征 (B, N, C)</span></span>
<span id="cb2-58"><a href="#cb2-58"></a><span class="co">        """</span></span>
<span id="cb2-59"><a href="#cb2-59"></a>        xyz <span class="op">=</span> xyz.permute(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb2-60"><a href="#cb2-60"></a>        <span class="cf">if</span> points <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-61"><a href="#cb2-61"></a>            points <span class="op">=</span> points.permute(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb2-62"><a href="#cb2-62"></a></span>
<span id="cb2-63"><a href="#cb2-63"></a>        <span class="cf">if</span> <span class="va">self</span>.group_all:</span>
<span id="cb2-64"><a href="#cb2-64"></a>            new_xyz, new_points <span class="op">=</span> sample_and_group_all(xyz, points)</span>
<span id="cb2-65"><a href="#cb2-65"></a>        <span class="cf">else</span>:</span>
<span id="cb2-66"><a href="#cb2-66"></a>            new_xyz, new_points <span class="op">=</span> sample_and_group(</span>
<span id="cb2-67"><a href="#cb2-67"></a>                <span class="va">self</span>.npoint, <span class="va">self</span>.radius, <span class="va">self</span>.nsample, xyz, points)</span>
<span id="cb2-68"><a href="#cb2-68"></a></span>
<span id="cb2-69"><a href="#cb2-69"></a>        <span class="co"># 对每个局部区域应用PointNet</span></span>
<span id="cb2-70"><a href="#cb2-70"></a>        new_points <span class="op">=</span> new_points.permute(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>)  <span class="co"># [B, C+D, nsample, npoint]</span></span>
<span id="cb2-71"><a href="#cb2-71"></a>        <span class="cf">for</span> i, conv <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.mlp_convs):</span>
<span id="cb2-72"><a href="#cb2-72"></a>            bn <span class="op">=</span> <span class="va">self</span>.mlp_bns[i]</span>
<span id="cb2-73"><a href="#cb2-73"></a>            new_points <span class="op">=</span> F.relu(bn(conv(new_points)))</span>
<span id="cb2-74"><a href="#cb2-74"></a></span>
<span id="cb2-75"><a href="#cb2-75"></a>        <span class="co"># 局部特征聚合</span></span>
<span id="cb2-76"><a href="#cb2-76"></a>        new_points <span class="op">=</span> torch.<span class="bu">max</span>(new_points, <span class="dv">2</span>)[<span class="dv">0</span>]</span>
<span id="cb2-77"><a href="#cb2-77"></a>        new_xyz <span class="op">=</span> new_xyz.permute(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb2-78"><a href="#cb2-78"></a>        <span class="cf">return</span> new_xyz, new_points</span>
<span id="cb2-79"><a href="#cb2-79"></a></span>
<span id="cb2-80"><a href="#cb2-80"></a><span class="kw">class</span> PointNetPlusPlus(nn.Module):</span>
<span id="cb2-81"><a href="#cb2-81"></a>    <span class="co">"""PointNet++网络架构"""</span></span>
<span id="cb2-82"><a href="#cb2-82"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_classes):</span>
<span id="cb2-83"><a href="#cb2-83"></a>        <span class="bu">super</span>(PointNetPlusPlus, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb2-84"><a href="#cb2-84"></a></span>
<span id="cb2-85"><a href="#cb2-85"></a>        <span class="co"># 编码器</span></span>
<span id="cb2-86"><a href="#cb2-86"></a>        <span class="va">self</span>.sa1 <span class="op">=</span> SetAbstraction(<span class="dv">512</span>, <span class="fl">0.2</span>, <span class="dv">32</span>, <span class="dv">3</span>, [<span class="dv">64</span>, <span class="dv">64</span>, <span class="dv">128</span>], <span class="va">False</span>)</span>
<span id="cb2-87"><a href="#cb2-87"></a>        <span class="va">self</span>.sa2 <span class="op">=</span> SetAbstraction(<span class="dv">128</span>, <span class="fl">0.4</span>, <span class="dv">64</span>, <span class="dv">128</span> <span class="op">+</span> <span class="dv">3</span>, [<span class="dv">128</span>, <span class="dv">128</span>, <span class="dv">256</span>], <span class="va">False</span>)</span>
<span id="cb2-88"><a href="#cb2-88"></a>        <span class="va">self</span>.sa3 <span class="op">=</span> SetAbstraction(<span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="dv">256</span> <span class="op">+</span> <span class="dv">3</span>, [<span class="dv">256</span>, <span class="dv">512</span>, <span class="dv">1024</span>], <span class="va">True</span>)</span>
<span id="cb2-89"><a href="#cb2-89"></a></span>
<span id="cb2-90"><a href="#cb2-90"></a>        <span class="co"># 分类头</span></span>
<span id="cb2-91"><a href="#cb2-91"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">1024</span>, <span class="dv">512</span>)</span>
<span id="cb2-92"><a href="#cb2-92"></a>        <span class="va">self</span>.bn1 <span class="op">=</span> nn.BatchNorm1d(<span class="dv">512</span>)</span>
<span id="cb2-93"><a href="#cb2-93"></a>        <span class="va">self</span>.drop1 <span class="op">=</span> nn.Dropout(<span class="fl">0.4</span>)</span>
<span id="cb2-94"><a href="#cb2-94"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">512</span>, <span class="dv">256</span>)</span>
<span id="cb2-95"><a href="#cb2-95"></a>        <span class="va">self</span>.bn2 <span class="op">=</span> nn.BatchNorm1d(<span class="dv">256</span>)</span>
<span id="cb2-96"><a href="#cb2-96"></a>        <span class="va">self</span>.drop2 <span class="op">=</span> nn.Dropout(<span class="fl">0.4</span>)</span>
<span id="cb2-97"><a href="#cb2-97"></a>        <span class="va">self</span>.fc3 <span class="op">=</span> nn.Linear(<span class="dv">256</span>, num_classes)</span>
<span id="cb2-98"><a href="#cb2-98"></a></span>
<span id="cb2-99"><a href="#cb2-99"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, xyz):</span>
<span id="cb2-100"><a href="#cb2-100"></a>        B, _, _ <span class="op">=</span> xyz.shape</span>
<span id="cb2-101"><a href="#cb2-101"></a></span>
<span id="cb2-102"><a href="#cb2-102"></a>        <span class="co"># 层次化特征提取</span></span>
<span id="cb2-103"><a href="#cb2-103"></a>        l1_xyz, l1_points <span class="op">=</span> <span class="va">self</span>.sa1(xyz, <span class="va">None</span>)</span>
<span id="cb2-104"><a href="#cb2-104"></a>        l2_xyz, l2_points <span class="op">=</span> <span class="va">self</span>.sa2(l1_xyz, l1_points)</span>
<span id="cb2-105"><a href="#cb2-105"></a>        l3_xyz, l3_points <span class="op">=</span> <span class="va">self</span>.sa3(l2_xyz, l2_points)</span>
<span id="cb2-106"><a href="#cb2-106"></a></span>
<span id="cb2-107"><a href="#cb2-107"></a>        <span class="co"># 全局特征</span></span>
<span id="cb2-108"><a href="#cb2-108"></a>        x <span class="op">=</span> l3_points.view(B, <span class="dv">1024</span>)</span>
<span id="cb2-109"><a href="#cb2-109"></a></span>
<span id="cb2-110"><a href="#cb2-110"></a>        <span class="co"># 分类预测</span></span>
<span id="cb2-111"><a href="#cb2-111"></a>        x <span class="op">=</span> <span class="va">self</span>.drop1(F.relu(<span class="va">self</span>.bn1(<span class="va">self</span>.fc1(x))))</span>
<span id="cb2-112"><a href="#cb2-112"></a>        x <span class="op">=</span> <span class="va">self</span>.drop2(F.relu(<span class="va">self</span>.bn2(<span class="va">self</span>.fc2(x))))</span>
<span id="cb2-113"><a href="#cb2-113"></a>        x <span class="op">=</span> <span class="va">self</span>.fc3(x)</span>
<span id="cb2-114"><a href="#cb2-114"></a></span>
<span id="cb2-115"><a href="#cb2-115"></a>        <span class="cf">return</span> F.log_softmax(x, <span class="op">-</span><span class="dv">1</span>)</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="point-transformer的核心实现" class="level3" data-number="6.4.3">
<h3 data-number="6.4.3" class="anchored" data-anchor-id="point-transformer的核心实现"><span class="header-section-number">6.4.3</span> Point-Transformer的核心实现</h3>
<p>Point-Transformer引入自注意力机制处理点云：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> PointTransformerLayer(nn.Module):</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="co">"""Point-Transformer层：自注意力机制"""</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, in_planes, out_planes<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-4"><a href="#cb3-4"></a>        <span class="bu">super</span>(PointTransformerLayer, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb3-5"><a href="#cb3-5"></a>        <span class="va">self</span>.in_planes <span class="op">=</span> in_planes</span>
<span id="cb3-6"><a href="#cb3-6"></a>        <span class="va">self</span>.out_planes <span class="op">=</span> out_planes <span class="kw">or</span> in_planes</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a>        <span class="co"># 线性变换层</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>        <span class="va">self</span>.q_conv <span class="op">=</span> nn.Conv1d(in_planes, in_planes, <span class="dv">1</span>, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-10"><a href="#cb3-10"></a>        <span class="va">self</span>.k_conv <span class="op">=</span> nn.Conv1d(in_planes, in_planes, <span class="dv">1</span>, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-11"><a href="#cb3-11"></a>        <span class="va">self</span>.v_conv <span class="op">=</span> nn.Conv1d(in_planes, <span class="va">self</span>.out_planes, <span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a>        <span class="co"># 位置编码网络</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>        <span class="va">self</span>.pos_mlp <span class="op">=</span> nn.Sequential(</span>
<span id="cb3-15"><a href="#cb3-15"></a>            nn.Conv2d(<span class="dv">3</span>, in_planes, <span class="dv">1</span>, bias<span class="op">=</span><span class="va">False</span>),</span>
<span id="cb3-16"><a href="#cb3-16"></a>            nn.BatchNorm2d(in_planes),</span>
<span id="cb3-17"><a href="#cb3-17"></a>            nn.ReLU(inplace<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb3-18"><a href="#cb3-18"></a>            nn.Conv2d(in_planes, in_planes, <span class="dv">1</span>)</span>
<span id="cb3-19"><a href="#cb3-19"></a>        )</span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="co"># 注意力权重网络</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>        <span class="va">self</span>.attn_mlp <span class="op">=</span> nn.Sequential(</span>
<span id="cb3-23"><a href="#cb3-23"></a>            nn.Conv2d(in_planes, in_planes, <span class="dv">1</span>, bias<span class="op">=</span><span class="va">False</span>),</span>
<span id="cb3-24"><a href="#cb3-24"></a>            nn.BatchNorm2d(in_planes),</span>
<span id="cb3-25"><a href="#cb3-25"></a>            nn.ReLU(inplace<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb3-26"><a href="#cb3-26"></a>            nn.Conv2d(in_planes, in_planes, <span class="dv">1</span>)</span>
<span id="cb3-27"><a href="#cb3-27"></a>        )</span>
<span id="cb3-28"><a href="#cb3-28"></a></span>
<span id="cb3-29"><a href="#cb3-29"></a>        <span class="va">self</span>.softmax <span class="op">=</span> nn.Softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-30"><a href="#cb3-30"></a></span>
<span id="cb3-31"><a href="#cb3-31"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, xyz, features, neighbor_idx):</span>
<span id="cb3-32"><a href="#cb3-32"></a>        <span class="co">"""</span></span>
<span id="cb3-33"><a href="#cb3-33"></a><span class="co">        xyz: 点坐标 (B, N, 3)</span></span>
<span id="cb3-34"><a href="#cb3-34"></a><span class="co">        features: 点特征 (B, C, N)</span></span>
<span id="cb3-35"><a href="#cb3-35"></a><span class="co">        neighbor_idx: 邻居索引 (B, N, K)</span></span>
<span id="cb3-36"><a href="#cb3-36"></a><span class="co">        """</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>        B, C, N <span class="op">=</span> features.shape</span>
<span id="cb3-38"><a href="#cb3-38"></a>        _, _, K <span class="op">=</span> neighbor_idx.shape</span>
<span id="cb3-39"><a href="#cb3-39"></a></span>
<span id="cb3-40"><a href="#cb3-40"></a>        <span class="co"># 计算查询、键、值</span></span>
<span id="cb3-41"><a href="#cb3-41"></a>        q <span class="op">=</span> <span class="va">self</span>.q_conv(features)  <span class="co"># (B, C, N)</span></span>
<span id="cb3-42"><a href="#cb3-42"></a>        k <span class="op">=</span> <span class="va">self</span>.k_conv(features)  <span class="co"># (B, C, N)</span></span>
<span id="cb3-43"><a href="#cb3-43"></a>        v <span class="op">=</span> <span class="va">self</span>.v_conv(features)  <span class="co"># (B, C', N)</span></span>
<span id="cb3-44"><a href="#cb3-44"></a></span>
<span id="cb3-45"><a href="#cb3-45"></a>        <span class="co"># 获取邻居特征</span></span>
<span id="cb3-46"><a href="#cb3-46"></a>        k_neighbors <span class="op">=</span> index_points(k.transpose(<span class="dv">1</span>, <span class="dv">2</span>), neighbor_idx)  <span class="co"># (B, N, K, C)</span></span>
<span id="cb3-47"><a href="#cb3-47"></a>        v_neighbors <span class="op">=</span> index_points(v.transpose(<span class="dv">1</span>, <span class="dv">2</span>), neighbor_idx)  <span class="co"># (B, N, K, C')</span></span>
<span id="cb3-48"><a href="#cb3-48"></a></span>
<span id="cb3-49"><a href="#cb3-49"></a>        <span class="co"># 计算相对位置</span></span>
<span id="cb3-50"><a href="#cb3-50"></a>        xyz_neighbors <span class="op">=</span> index_points(xyz, neighbor_idx)  <span class="co"># (B, N, K, 3)</span></span>
<span id="cb3-51"><a href="#cb3-51"></a>        relative_pos <span class="op">=</span> xyz.unsqueeze(<span class="dv">2</span>) <span class="op">-</span> xyz_neighbors  <span class="co"># (B, N, K, 3)</span></span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a>        <span class="co"># 位置编码</span></span>
<span id="cb3-54"><a href="#cb3-54"></a>        pos_encoding <span class="op">=</span> <span class="va">self</span>.pos_mlp(relative_pos.permute(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>))  <span class="co"># (B, C, N, K)</span></span>
<span id="cb3-55"><a href="#cb3-55"></a>        pos_encoding <span class="op">=</span> pos_encoding.permute(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>)  <span class="co"># (B, N, K, C)</span></span>
<span id="cb3-56"><a href="#cb3-56"></a></span>
<span id="cb3-57"><a href="#cb3-57"></a>        <span class="co"># 计算注意力权重</span></span>
<span id="cb3-58"><a href="#cb3-58"></a>        q_expanded <span class="op">=</span> q.transpose(<span class="dv">1</span>, <span class="dv">2</span>).unsqueeze(<span class="dv">2</span>)  <span class="co"># (B, N, 1, C)</span></span>
<span id="cb3-59"><a href="#cb3-59"></a>        attention_input <span class="op">=</span> q_expanded <span class="op">-</span> k_neighbors <span class="op">+</span> pos_encoding  <span class="co"># (B, N, K, C)</span></span>
<span id="cb3-60"><a href="#cb3-60"></a>        attention_weights <span class="op">=</span> <span class="va">self</span>.attn_mlp(attention_input.permute(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>))  <span class="co"># (B, C, N, K)</span></span>
<span id="cb3-61"><a href="#cb3-61"></a>        attention_weights <span class="op">=</span> <span class="va">self</span>.softmax(attention_weights.permute(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>))  <span class="co"># (B, N, K, C)</span></span>
<span id="cb3-62"><a href="#cb3-62"></a></span>
<span id="cb3-63"><a href="#cb3-63"></a>        <span class="co"># 加权聚合</span></span>
<span id="cb3-64"><a href="#cb3-64"></a>        output <span class="op">=</span> torch.<span class="bu">sum</span>(attention_weights <span class="op">*</span> (v_neighbors <span class="op">+</span> pos_encoding), dim<span class="op">=</span><span class="dv">2</span>)  <span class="co"># (B, N, C')</span></span>
<span id="cb3-65"><a href="#cb3-65"></a></span>
<span id="cb3-66"><a href="#cb3-66"></a>        <span class="cf">return</span> output.transpose(<span class="dv">1</span>, <span class="dv">2</span>)  <span class="co"># (B, C', N)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>这些核心实现展示了PointNet系列网络的关键设计思想：PointNet通过对称函数保证置换不变性，PointNet++通过层次化采样捕获局部结构，Point-Transformer通过自注意力机制建模长距离依赖关系。</p>
</section>
</section>
<section id="网络性能评估" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="网络性能评估"><span class="header-section-number">6.5</span> 网络性能评估</h2>
<p>PointNet系列网络在多个点云处理任务上取得了显著的性能提升，推动了整个领域的发展。</p>
<section id="网络性能对比分析" class="level3" data-number="6.5.1">
<h3 data-number="6.5.1" class="anchored" data-anchor-id="网络性能对比分析"><span class="header-section-number">6.5.1</span> 网络性能对比分析</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph 分类任务性能
        A["传统方法&lt;br/&gt;准确率: 70-80%&lt;br/&gt;特征: 手工设计"]
        B["PointNet&lt;br/&gt;准确率: 89.2%&lt;br/&gt;特征: 端到端学习"]
        C["PointNet++&lt;br/&gt;准确率: 91.9%&lt;br/&gt;特征: 层次化表示"]
        D["Point-Transformer&lt;br/&gt;准确率: 93.7%&lt;br/&gt;特征: 自注意力"]
    end

    subgraph 分割任务性能
        E["传统方法&lt;br/&gt;mIoU: 60-70%&lt;br/&gt;依赖: 几何特征"]
        F["PointNet&lt;br/&gt;mIoU: 83.7%&lt;br/&gt;依赖: 全局特征"]
        G["PointNet++&lt;br/&gt;mIoU: 85.1%&lt;br/&gt;依赖: 局部+全局"]
        H["Point-Transformer&lt;br/&gt;mIoU: 87.3%&lt;br/&gt;依赖: 长距离关系"]
    end

    subgraph 计算效率
        I["推理速度&lt;br/&gt;FPS"]
        J["内存占用&lt;br/&gt;GPU Memory"]
        K["训练时间&lt;br/&gt;Convergence"]
    end

    A --&gt; E
    B --&gt; F
    C --&gt; G
    D --&gt; H

    B --&gt; I
    C --&gt; J
    D --&gt; K

    classDef tradNode fill:#ef5350,stroke:#c62828,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef pointnetNode fill:#64b5f6,stroke:#1565c0,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef pointnet2Node fill:#ba68c8,stroke:#7b1fa2,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef transformerNode fill:#4caf50,stroke:#2e7d32,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef metricNode fill:#ffb74d,stroke:#e65100,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px

    classDef classSubgraph fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1,font-weight:bold
    classDef segSubgraph fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#4a148c,font-weight:bold
    classDef efficiencySubgraph fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#bf360c,font-weight:bold

    class A tradNode
    class B,I pointnetNode
    class C,G,J pointnet2Node
    class D,H,K transformerNode
    class E tradNode
    class F pointnetNode

    class 分类任务性能 classSubgraph
    class 分割任务性能 segSubgraph
    class 计算效率 efficiencySubgraph

    linkStyle 0,1,2,3,4,5,6 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.25：PointNet系列网络在不同任务上的性能对比</em></p>
</section>
<section id="网络架构演进分析" class="level3" data-number="6.5.2">
<h3 data-number="6.5.2" class="anchored" data-anchor-id="网络架构演进分析"><span class="header-section-number">6.5.2</span> 网络架构演进分析</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    subgraph 技术演进路径
        A["PointNet&lt;br/&gt;(2017)"]
        B["PointNet++&lt;br/&gt;(2017)"]
        C["Point-Transformer&lt;br/&gt;(2021)"]
    end

    subgraph 关键创新点
        D["对称函数&lt;br/&gt;置换不变性"]
        E["层次采样&lt;br/&gt;局部结构"]
        F["自注意力&lt;br/&gt;长距离依赖"]
    end

    subgraph 应用拓展
        G["分类分割&lt;br/&gt;基础任务"]
        H["目标检测&lt;br/&gt;复杂场景"]
        I["场景理解&lt;br/&gt;语义分析"]
    end

    A --&gt; B --&gt; C
    A --&gt; D
    B --&gt; E
    C --&gt; F

    D --&gt; G
    E --&gt; H
    F --&gt; I

    classDef evolutionNode fill:#42a5f5,stroke:#1565c0,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    classDef innovationNode fill:#ba68c8,stroke:#7b1fa2,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px
    classDef applicationNode fill:#66bb6a,stroke:#2e7d32,color:white,stroke-width:2px,font-weight:bold,font-size:14px,border-radius:8px

    classDef evolutionSubgraph fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1,font-weight:bold
    classDef innovationSubgraph fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#4a148c,font-weight:bold
    classDef applicationSubgraph fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,color:#1b5e20,font-weight:bold

    class A,B,C evolutionNode
    class D,E,F innovationNode
    class G,H,I applicationNode

    class 技术演进路径 evolutionSubgraph
    class 关键创新点 innovationSubgraph
    class 应用拓展 applicationSubgraph

    linkStyle 0,1,2,3,4,5,6,7 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.26：PointNet系列网络的技术演进与应用拓展</em></p>
</section>
<section id="数据集性能基准测试" class="level3" data-number="6.5.3">
<h3 data-number="6.5.3" class="anchored" data-anchor-id="数据集性能基准测试"><span class="header-section-number">6.5.3</span> 数据集性能基准测试</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph ModelNet40分类
        A["PointNet: 89.2%&lt;br/&gt;首次端到端学习"]
        B["PointNet++: 91.9%&lt;br/&gt;层次特征提升"]
        C["Point-Transformer: 93.7%&lt;br/&gt;注意力机制优化"]
    end

    subgraph ShapeNet分割
        D["PointNet: 83.7% mIoU&lt;br/&gt;全局特征局限"]
        E["PointNet++: 85.1% mIoU&lt;br/&gt;局部细节改善"]
        F["Point-Transformer: 87.3% mIoU&lt;br/&gt;长距离建模"]
    end

    subgraph S3DIS场景分割
        G["PointNet: 47.6% mIoU&lt;br/&gt;复杂场景挑战"]
        H["PointNet++: 53.5% mIoU&lt;br/&gt;多尺度处理"]
        I["Point-Transformer: 58.0% mIoU&lt;br/&gt;上下文理解"]
    end

    subgraph 性能提升因素
        J["数据增强&lt;br/&gt;旋转、缩放、噪声"]
        K["网络深度&lt;br/&gt;更多层次特征"]
        L["注意力机制&lt;br/&gt;自适应权重"]
        M["多任务学习&lt;br/&gt;联合优化"]
    end

    A --&gt; D --&gt; G
    B --&gt; E --&gt; H
    C --&gt; F --&gt; I

    J --&gt; A
    K --&gt; B
    L --&gt; C
    M --&gt; C

    classDef modelnetNode fill:#64b5f6,stroke:#1565c0,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef shapenetNode fill:#ba68c8,stroke:#7b1fa2,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef s3disNode fill:#4caf50,stroke:#2e7d32,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef factorNode fill:#ffb74d,stroke:#e65100,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px

    classDef modelnetSubgraph fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1,font-weight:bold
    classDef shapenetSubgraph fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#4a148c,font-weight:bold
    classDef s3disSubgraph fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,color:#1b5e20,font-weight:bold
    classDef factorSubgraph fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#bf360c,font-weight:bold

    class A,B,C modelnetNode
    class D,E,F shapenetNode
    class G,H,I s3disNode
    class J,K,L,M factorNode

    class ModelNet40分类 modelnetSubgraph
    class ShapeNet分割 shapenetSubgraph
    class S3DIS场景分割 s3disSubgraph
    class 性能提升因素 factorSubgraph

    linkStyle 0,1,2,3,4,5,6,7,8 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.27：PointNet系列网络在主要数据集上的性能基准</em></p>
</section>
<section id="应用场景适应性分析" class="level3" data-number="6.5.4">
<h3 data-number="6.5.4" class="anchored" data-anchor-id="应用场景适应性分析"><span class="header-section-number">6.5.4</span> 应用场景适应性分析</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph 室内场景
        A["家具识别&lt;br/&gt;PointNet++适用"]
        B["房间分割&lt;br/&gt;Point-Transformer优势"]
        C["物体检测&lt;br/&gt;层次特征重要"]
    end

    subgraph 室外场景
        D["自动驾驶&lt;br/&gt;实时性要求"]
        E["城市建模&lt;br/&gt;大规模处理"]
        F["地形分析&lt;br/&gt;多尺度特征"]
    end

    subgraph 工业应用
        G["质量检测&lt;br/&gt;精度要求高"]
        H["机器人抓取&lt;br/&gt;几何理解"]
        I["逆向工程&lt;br/&gt;形状重建"]
    end

    subgraph 技术挑战
        J["密度不均&lt;br/&gt;采样策略"]
        K["噪声干扰&lt;br/&gt;鲁棒性"]
        L["计算效率&lt;br/&gt;实时处理"]
        M["泛化能力&lt;br/&gt;跨域适应"]
    end

    A --&gt; J
    B --&gt; K
    C --&gt; L
    D --&gt; L
    E --&gt; M
    F --&gt; J
    G --&gt; K
    H --&gt; L
    I --&gt; M

    classDef indoorNode fill:#4db6ac,stroke:#00796b,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef outdoorNode fill:#ba68c8,stroke:#7b1fa2,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef industrialNode fill:#ffb74d,stroke:#e65100,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px
    classDef challengeNode fill:#ef5350,stroke:#c62828,color:white,stroke-width:2px,font-weight:bold,font-size:13px,border-radius:8px

    classDef indoorSubgraph fill:#e0f2f1,stroke:#00796b,stroke-width:2px,color:#004d40,font-weight:bold
    classDef outdoorSubgraph fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#4a148c,font-weight:bold
    classDef industrialSubgraph fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#bf360c,font-weight:bold
    classDef challengeSubgraph fill:#ffebee,stroke:#c62828,stroke-width:2px,color:#b71c1c,font-weight:bold

    class A,B,C indoorNode
    class D,E,F outdoorNode
    class G,H,I industrialNode
    class J,K,L,M challengeNode

    class 室内场景 indoorSubgraph
    class 室外场景 outdoorSubgraph
    class 工业应用 industrialSubgraph
    class 技术挑战 challengeSubgraph

    linkStyle 0,1,2,3,4,5,6,7,8 stroke-width:1.5px
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>图11.28：PointNet系列网络在不同应用场景中的适应性与挑战</em></p>
</section>
</section>
<section id="小结" class="level2" data-number="6.6">
<h2 data-number="6.6" class="anchored" data-anchor-id="小结"><span class="header-section-number">6.6</span> 小结</h2>
<p>PointNet系列网络代表了点云深度学习的重要里程碑，从根本上改变了点云处理的技术范式。本节系统介绍了从PointNet到Point-Transformer的技术演进，展示了深度学习在点云处理中的革命性突破。</p>
<p>本节的核心贡献在于：<strong>理论层面</strong>，阐述了对称函数、层次化表示学习和自注意力机制的数学原理；<strong>技术层面</strong>，详细分析了网络架构的设计思想和关键组件；<strong>应用层面</strong>，展示了这些网络在分类、分割等任务上的性能提升和应用潜力。</p>
<p>PointNet系列网络与前面章节形成了完整的技术链条：传统点云处理方法提供了数据预处理和特征工程的基础，而深度学习方法则实现了端到端的特征学习和任务优化。这种技术演进不仅提升了点云处理的性能，也为三维目标检测、场景理解等高级应用奠定了基础。</p>
<p>随着Transformer架构在计算机视觉领域的成功应用，点云深度学习正朝着更强的表达能力、更好的泛化性能和更高的计算效率方向发展。未来的研究将继续探索新的网络架构、训练策略和应用场景，推动三维视觉技术在自动驾驶、机器人、数字孪生等领域的广泛应用。</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "已复制");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "已复制");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapter11/11.4_点云基础与处理.html" class="pagination-link" aria-label="点云基础与处理">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">点云基础与处理</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapter11/11.6_3D目标检测.html" class="pagination-link" aria-label="3D目标检测">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">3D目标检测</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2024 现代计算机视觉教程</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/guxinghaoyun/quarto-web/edit/main/chapter11/11.5_PointNet系列网络.qmd" class="toc-action"><i class="bi bi-github"></i>编辑该页面</a></li><li><a href="https://github.com/guxinghaoyun/quarto-web/issues/new" class="toc-action"><i class="bi empty"></i>反馈问题</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>使用 <a href="https://quarto.org/">Quarto</a> 构建</p>
</div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>